"use strict";(self.webpackChunkwebpack_config=self.webpackChunkwebpack_config||[]).push([[841],{68419:(n,r,e)=>{e.d(r,{aT:()=>i,lA:()=>a,pb:()=>o,oG:()=>l});var s=e(75322);const t='## 配置一\n\n### antd 按需加载\n\n如果项目使用的是 typescript，那么在 webpack 配置中，需要把 antd 按需加载的设置写在编译 ts 中的 `babel-loader` 之下，不能写在编译 js 文件的 `babel-loader` 之下，否则将不生效，具体配置如下：\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.js(x?)$/,\n      exclude: /node_modules/,\n      use: [\n        {\n          loader: "babel-loader",\n          options: {\n            presets: ["@babel/preset-env", "@babel/preset-react", "mobx"],\n            plugins: [\n              "@babel/plugin-transform-runtime",\n              "@babel/plugin-proposal-class-properties",\n            ],\n          },\n        },\n      ],\n    },\n    {\n      test: /\\.ts(x?)$/,\n      exclude: /node_modules/,\n      use: [\n        {\n          loader: "babel-loader",\n          options: {\n            plugins: [\n              [\n                "import",\n                {\n                  libraryName: "antd",\n                  libraryDirectory: "es",\n                  style: true,\n                },\n              ],\n            ],\n          },\n        },\n        "ts-loader",\n      ],\n    },\n  ],\n},\n```\n\n### 解决开启 css 模块化导致 antd 自定义主题失效的问题\n\n解决这个问题需要在 webpack 中配置两次 `less-loader`，在未开启 css 模块化的 less-loader 中设置 antd 自定义主题的配置，在未设置 antd 自定义主题的 less-loader 中开启 css 模块化，具体配置如下：\n\n```js\nmodule: {\n  rules: [\n    /**\n     * 使用两次less-loader解决开启css模块化时导致antd自定义主题失效的问题。\n     * 需要在不开启模块化时，设置antd自定义主题才会生效，因此这一个less-loader使用include针对node_modules中的组件库（即antd）在不开启css块化的情况下，开启自定义主题的设置。\n     *\n     */\n    {\n      test: /\\.less$/,\n      include: [/node_modules/],\n      use: [\n        "style-loader",\n        "css-loader",\n        "postcss-loader",\n        {\n          loader: "less-loader",\n          options: {\n            lessOptions: {\n              // 如果使用less-loader@5，请移除 lessOptions 这一级直接配置选项。\n              sourceMap: true,\n              modifyVars: {\n                "primary-color": "#1DA57A",\n                "link-color": "#1DA57A",\n                "border-radius-base": "2px",\n              },\n              javascriptEnabled: true,\n            },\n          },\n        },\n      ],\n    },\n    /**\n     * 该less-loader使用exclude排除node_modules中的组件库，只针对自己的代码开启css模块化\n     */\n    {\n      test: /\\.less$/,\n      exclude: [/node_modules/],\n      use: [\n        "style-loader",\n        // 配置less模块化导入\n        {\n          loader: "css-loader",\n          options: {\n            modules: {\n              localIdentName: "[name]__[local]--[hash:base64:5]",\n            },\n            importLoaders: 1,\n          },\n        },\n        "postcss-loader",\n        "less-loader",\n      ],\n    },\n  ],\n},\n```\n\n### 防止 browserRouter 路由模式出现 404\n\n需要在 webpack 中的 `devServer` 中配置如下属性：\n\n```js\nhistoryApiFallback: true,\n```\n\n### 解决页面切到子路由时出现找不到 js 资源的报错\n\n要防止刷新页面后出现页面丢失报：`GET http://localhost:9000/home/js/bundle.js net::ERR_ABORTED 404 (Not Found)`，需要在 `output` 中增加 `publicPath` 属性，配置如下：\n\n```js\noutput: {\n  filename: "js/[name]-bundle-[hash:6].js",\n  path: path.resolve(__dirname, "../dist"),\n  publicPath: "/",\n},\n```\n\n### 解决 eslint 与 Prettier 之间的冲突\n\n首先安装如下插件：\n\n```\nyarn add eslint-config-prettier eslint-plugin-prettier -D\n```\n\n之后在 `.eslintrc.js` 中修改如下配置：\n\n```js\n{\n  // ...\n - "extends": ["eslint:recommended", "standard"]\n + "extends": ["eslint:recommended", "standard",  "plugin:prettier/recommended"]\n  // ...\n}\n```\n\n### 解决路径别名 eslint 报错\n\n首先安装如下插件：\n\n```js\nyarn add eslint-import-resolver-webpack -D\n```\n\n增加一个与 rules 配置同级的 settings 配置：\n\n```json\n"import/resolver": {\n  "webpack": {\n    "config": "./config/webpack.common.config.js"\n  }\n}\n```\n\n### 配置 husky\n\n首先需要安装 husky：\n\n```js\nyarn add husky -D\n```\n\n之后执行如下命令生成 `.husky` 文件，并在该文件夹下生成 `pre-commit` 文件：\n\n```js\nnpm set-script prepare "husky install"\n\nnpm run prepare\n\nnpx husky add .husky/pre-commit "npm test"\n```\n\n> 注意：执行 npm set-script prepare "husky install" 之前，必须要先使用 git init 创建 .git 文件，否则将会执行失败。\n\n最后在 `package.json` 文件中增加如下两条脚本：\n\n```js\n{\n  "scripts": {\n    // ...\n+   "prepare": "husky install",\n+   "test": "npx eslint ./src"\n  }\n}\n```\n\n### npx eslint ./src\n\n注意：如果 src 的入口文件是 `.ts | .tsx` 时，执行 `npx eslint ./src` 会出现找不到 src 文件的报错，因此在执行的时候需要加上如下后缀：\n\n```js\nnpx eslint ./src --ext ts,tsx\n```\n\n配置自动修复部分 eslint 报错，只需要在上述脚本的末尾加上 `--fix` 即可：\n\n```js\nnpx eslint ./src --ext ts,tsx --fix\n```\n\n### husky 执行报错处理\n\n当使用 mac 生成 `.husky` 文件时，在 windows 上执行会报：`error: cannot spawn .husky/pre-commit: No such file or directory` 这个错误，出现这个错误的原因是因为 mac 与 windows 两者之间的换行符不同。\n\n解决这个报错的方式是：将原有的 `.husky` 文件删除，重新执行上述命令生成。\n\n### 处理 LF 与 CRLF 转换问题\n\nGit 可以在你 push 时自动地把行结束符 CRLF 转换成 LF，而在 pull 代码时把 LF 转换成 CRLF。用 `core.autocrlf` 来打开此项功能，如果是在 Windows 系统上，把它设置成 `true`，这样当签出代码时，LF 会被转换成 CRLF：\n\n```js\ngit config --global core.autocrlf true\n```\n\nLinux 或 Mac 系统使用 LF 作为行结束符；当一个以 CRLF 为行结束符的文件不小心被引入时你肯定想进行修正，把 `core.autocrlf` 设置成 `input` 来告诉 Git 在 push 时把 CRLF 转换成 LF，pull 时不转换：\n\n```js\ngit config --global core.autocrlf input\n```\n\n在本地和代码库中都保留 LF，无论 pull 还是 push 都不变，代码库什么样，本地还是什么样子：\n\n```js\ngit config --global core.autocrlf false\n```\n\n## 配置二\n\n### antd 按需加载\n\n如果项目使用的是 typescript，那么在 webpack 配置中，需要把 antd 按需加载的设置写在编译 ts 中的 `babel-loader` 之下，不能写在编译 js 文件的 `babel-loader` 之下，否则将不生效，具体配置如下：\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.js(x?)$/,\n      exclude: /node_modules/,\n      use: [\n        {\n          loader: "babel-loader",\n          options: {\n            presets: ["@babel/preset-env", "@babel/preset-react", "mobx"],\n            plugins: [\n              "@babel/plugin-transform-runtime",\n              "@babel/plugin-proposal-class-properties",\n            ],\n          },\n        },\n      ],\n    },\n    {\n      test: /\\.ts(x?)$/,\n      exclude: /node_modules/,\n      use: [\n        {\n          loader: "babel-loader",\n          options: {\n            plugins: [\n              [\n                "import",\n                {\n                  libraryName: "antd",\n                  libraryDirectory: "es",\n                  style: true,\n                },\n              ],\n            ],\n          },\n        },\n        "ts-loader",\n      ],\n    },\n  ],\n},\n```\n\n### 解决开启 css 模块化导致 antd 自定义主题失效的问题\n\n解决这个问题需要在 webpack 中配置两次 `less-loader`，在未开启 css 模块化的 less-loader 中设置 antd 自定义主题的配置，在未设置 antd 自定义主题的 less-loader 中开启 css 模块化，具体配置如下：\n\n```js\nmodule: {\n  rules: [\n    /**\n     * 使用两次less-loader解决开启css模块化时导致antd自定义主题失效的问题。\n     * 需要在不开启模块化时，设置antd自定义主题才会生效，因此这一个less-loader使用include针对node_modules中的组件库（即antd）在不开启css块化的情况下，开启自定义主题的设置。\n     *\n     */\n    {\n      test: /\\.less$/,\n      include: [/node_modules/],\n      use: [\n        "style-loader",\n        "css-loader",\n        "postcss-loader",\n        {\n          loader: "less-loader",\n          options: {\n            lessOptions: {\n              // 如果使用less-loader@5，请移除 lessOptions 这一级直接配置选项。\n              sourceMap: true,\n              modifyVars: {\n                "primary-color": "#1DA57A",\n                "link-color": "#1DA57A",\n                "border-radius-base": "2px",\n              },\n              javascriptEnabled: true,\n            },\n          },\n        },\n      ],\n    },\n    /**\n     * 该less-loader使用exclude排除node_modules中的组件库，只针对自己的代码开启css模块化\n     */\n    {\n      test: /\\.less$/,\n      exclude: [/node_modules/],\n      use: [\n        "style-loader",\n        // 配置less模块化导入\n        {\n          loader: "css-loader",\n          options: {\n            modules: {\n              localIdentName: "[name]__[local]--[hash:base64:5]",\n            },\n            importLoaders: 1,\n          },\n        },\n        "postcss-loader",\n        "less-loader",\n      ],\n    },\n  ],\n},\n```\n\n### 防止 browserRouter 路由模式出现 404\n\n需要在 webpack 中的 `devServer` 中配置如下属性：\n\n```js\nhistoryApiFallback: true,\n```\n\n### 解决页面切到子路由时出现找不到 js 资源的报错\n\n要防止刷新页面后出现页面丢失报：`GET http://localhost:9000/home/js/bundle.js net::ERR_ABORTED 404 (Not Found)`，需要在 `output` 中增加 `publicPath` 属性，配置如下：\n\n```js\noutput: {\n  filename: "js/[name]-bundle-[hash:6].js",\n  path: path.resolve(__dirname, "../dist"),\n  publicPath: "/",\n},\n```\n\n### 解决 eslint 与 Prettier 之间的冲突\n\n首先安装如下插件：\n\n```\nyarn add eslint-config-prettier eslint-plugin-prettier -D\n```\n\n之后在 `.eslintrc.js` 中修改如下配置：\n\n```js\n{\n  // ...\n - "extends": ["eslint:recommended", "standard"]\n + "extends": ["eslint:recommended", "standard",  "plugin:prettier/recommended"]\n  // ...\n}\n```\n\n### 解决路径别名 eslint 报错\n\n首先安装如下插件：\n\n```js\nyarn add eslint-import-resolver-webpack -D\n```\n\n增加一个与 rules 配置同级的 settings 配置：\n\n```json\n"import/resolver": {\n  "webpack": {\n    "config": "./config/webpack.common.config.js"\n  }\n}\n```\n\n### 配置 husky\n\n首先需要安装 husky：\n\n```js\nyarn add husky -D\n```\n\n之后执行如下命令生成 `.husky` 文件，并在该文件夹下生成 `pre-commit` 文件：\n\n```js\nnpm set-script prepare "husky install"\n\nnpm run prepare\n\nnpx husky add .husky/pre-commit "npm test"\n```\n\n> 注意：执行 npm set-script prepare "husky install" 之前，必须要先使用 git init 创建 .git 文件，否则将会执行失败。\n\n最后在 `package.json` 文件中增加如下两条脚本：\n\n```js\n{\n  "scripts": {\n    // ...\n+   "prepare": "husky install",\n+   "test": "npx eslint ./src"\n  }\n}\n```\n\n### npx eslint ./src\n\n注意：如果 src 的入口文件是 `.ts | .tsx` 时，执行 `npx eslint ./src` 会出现找不到 src 文件的报错，因此在执行的时候需要加上如下后缀：\n\n```js\nnpx eslint ./src --ext ts,tsx\n```\n\n配置自动修复部分 eslint 报错，只需要在上述脚本的末尾加上 `--fix` 即可：\n\n```js\nnpx eslint ./src --ext ts,tsx --fix\n```\n\n### husky 执行报错处理\n\n当使用 mac 生成 `.husky` 文件时，在 windows 上执行会报：`error: cannot spawn .husky/pre-commit: No such file or directory` 这个错误，出现这个错误的原因是因为 mac 与 windows 两者之间的换行符不同。\n\n解决这个报错的方式是：将原有的 `.husky` 文件删除，重新执行上述命令生成。\n\n### 处理 LF 与 CRLF 转换问题\n\nGit 可以在你 push 时自动地把行结束符 CRLF 转换成 LF，而在 pull 代码时把 LF 转换成 CRLF。用 `core.autocrlf` 来打开此项功能，如果是在 Windows 系统上，把它设置成 `true`，这样当签出代码时，LF 会被转换成 CRLF：\n\n```js\ngit config --global core.autocrlf true\n```\n\nLinux 或 Mac 系统使用 LF 作为行结束符；当一个以 CRLF 为行结束符的文件不小心被引入时你肯定想进行修正，把 `core.autocrlf` 设置成 `input` 来告诉 Git 在 push 时把 CRLF 转换成 LF，pull 时不转换：\n\n```js\ngit config --global core.autocrlf input\n```\n\n在本地和代码库中都保留 LF，无论 pull 还是 push 都不变，代码库什么样，本地还是什么样子：\n\n```js\ngit config --global core.autocrlf false\n```\n';var o=[{id:"6",name:"webpackConfig",desc:"react + webpack + typescript + eslint 项目搭建",date:"2020-09-02"},{id:"1",name:"react template",desc:"react + webpack + typescript + eslint 项目搭建",date:"2020-06-13"},{id:"2",name:"JSON",desc:"JSON 数据测试",date:"2020-06-14"},{id:"3",name:"eslint",desc:"eslint 配置",date:"2020-06-15"},{id:"4",name:"react",desc:"react 配置",date:"2020-06-16"},{id:"5",name:"react18",desc:"react18 配置",date:"2020-06-17"},{id:"7",name:"jsModal",desc:"jsModal 配置",date:"2020-06-17"}],a=[{id:"6",detail:{name:"webpackConfig",desc:"react + webpack + typescript + eslint 项目搭建",mackdown:'### 初始化项目\r\n\r\n使用 `npm init -y` 生成 package.json 文件。\r\n\r\n### 安装 webpack\r\n\r\n```json\r\nyarn add webpack webpack-cli webpack-dev-server -D\r\n```\r\n\r\n#### 创建 config 文件夹\r\n\r\n在根目录创建 `config` 文件夹，并在其中创建如下文件：\r\n\r\n- `webpack.common.config.js`：用于编写 webpack 公共配置。\r\n\r\n- `webpack.dev.config.js`：用于配置 webpack 开发环境配置。\r\n\r\n- `webpack.prod.config.js`：用于 webpack 打包配置。\r\n\r\n#### 创建 public 文件夹\r\n\r\n在根目录中创建 public 文件夹，并在其中创建 `index.html` 文件：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang="en">\r\n  <head>\r\n    <meta charset="utf-8" />\r\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\r\n    <meta name="theme-color" content="#000000" />\r\n    <meta\r\n      name="description"\r\n      content="Web site created using create-react-app"\r\n    />\r\n    <title>dnhyxc</title>\r\n  </head>\r\n  <body translate="no">\r\n    <div id="root"></div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n#### 安装初始化所需插件\r\n\r\n**webpack-merge**：用于合并两个 webpack 配置，如下用于在 webpack.dev.config.js 中合并 webpack.common.config.js 中的配置。\r\n\r\n**html-webpack-plugin**：用于在指定的 html 模板文件中自动导入打包出来的 js 文件。\r\n\r\n```json\r\nyarn add webpack-merge html-webpack-plugin -D\r\n```\r\n\r\n### webpack 初始配置\r\n\r\n#### 打包公共配置\r\n\r\nwebpack.common.config.js 文件初始内容：\r\n\r\n```js\r\nconst path = require(\'path\');\r\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    index: \'./src/index.js\',\r\n  },\r\n  output: {\r\n    // 设置打包出来的 js 文件放置在 js 目录下\r\n    filename: \'js/[name]-bundle-[contenthash:6].js\',\r\n    path: path.resolve(__dirname, \'../dist\'),\r\n    // 防止刷新页面后出现页面丢失报错！GET http://localhost:9000/home/js/bundle.js net::ERR_ABORTED 404 (Not Found)\r\n    publicPath: \'/\',\r\n  },\r\n  plugins: [\r\n    /**\r\n     * HtmlWebpackPlugin 配置说明：\r\n     *  template：基于我们自己定义的 html 文件为模板生成 html 文件\r\n     *  filename：打包之后的 html 文件名字\r\n     *  inject：将 js 文件注入到 body 最底部\r\n     *  minify：压缩 html 文件时的配置\r\n     *   - removeComments：去除注释\r\n     */\r\n    new HtmlWebpackPlugin({\r\n      template: \'public/index.html\',\r\n      filename: \'index.html\',\r\n      // 配置浏览器标签图标\r\n      favicon: \'public/favicon.png\',\r\n      inject: \'body\',\r\n      minify: {\r\n        removeComments: true,\r\n      },\r\n    }),\r\n  ],\r\n};\r\n```\r\n\r\n- 在根目录中创建 src 文件夹，并在其中创建 `index.js` 文件：\r\n\r\n```js\r\nconst root = document.getElementById(\'root\');\r\nconsole.log(root);\r\nroot.textContent = \'hello word\';\r\n```\r\n\r\n#### 生产打包配置\r\n\r\nwebpack.prod.config.js 文件初始内容：\r\n\r\n```js\r\nconst { merge } = require(\'webpack-merge\');\r\nconst common = require(\'./webpack.common.config.js\');\r\n\r\nmodule.exports = merge(common, {\r\n  mode: \'production\',\r\n});\r\n```\r\n\r\n#### 开发打包配置\r\n\r\nwebpack.dev.config.js 文件初始内容：\r\n\r\n```js\r\nconst { merge } = require(\'webpack-merge\');\r\nconst common = require(\'./webpack.common.config.js\');\r\nmodule.exports = merge(common, {\r\n  mode: \'development\',\r\n  devServer: {\r\n    port: 9102,\r\n    compress: true,\r\n    // 设置 browserHistory 路由模式时，防止出现404的情况\r\n    historyApiFallback: true,\r\n    // 不将错误信息显示在浏览器中\r\n    client: {\r\n      overlay: false,\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n#### 修改 package.json 文件\r\n\r\n在 scripts 属性中增加如下配置：\r\n\r\n```json\r\n"scripts": {\r\n  "start": "webpack serve --config ./config/webpack.dev.config.js",\r\n  "build": "webpack --config ./config/webpack.prod.config.js"\r\n},\r\n```\r\n\r\n使用 `npm start` 命令启动项目，以及使用 `npm run build` 打包，看是否能正常运行。\r\n\r\n### 安装相关 babel 插件\r\n\r\n**@babel/core**：是 Babel 的核心库，所有的核心 Api 都在这个库里，这些 Api 供 babel-loader 调用。\r\n\r\n**babel-loader**：@babel/core 在做 es6 的语法转换和弥补缺失的功能，但是在使用 webpack 打包 js 时，webpack 并不知道应该怎么去调用这些规则去编译 js。这时就需要 babel-loader 了，它作为一个中间桥梁，通过调用 babel/core 中的 api 来告诉 webpack 要如何处理 js。\r\n\r\n**@babel/preset-react**：预设了一些 Babel 插件，主要负责编译 React 语法。\r\n\r\n**@babel/preset-env**：转译 ES2015+ 语法转义为 ES2015 支持的语法。\r\n\r\n**@babel/plugin-proposal-class-properties**：用来编译类(class)。\r\n\r\n**@babel/plugin-transform-runtime**：防止污染全局，代码复用和减少打包体积。\r\n\r\n```json\r\nyarn add babel-loader @babel/core @babel/preset-env @babel/preset-react @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D\r\n```\r\n\r\n#### 更新 webpack.common.config.js\r\n\r\n在 `module {}` 中的 `rules []` 配置中增加编译 js 及 jsx 的配置：\r\n\r\n```js\r\nconst path = require(\'path\');\r\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js(x?)$/,\r\n        exclude: /node_modules/,\r\n        use: [\r\n          {\r\n            loader: \'babel-loader\',\r\n            options: {\r\n              presets: [\'@babel/preset-env\', \'@babel/preset-react\'],\r\n              plugins: [\r\n                \'@babel/plugin-transform-runtime\',\r\n                \'@babel/plugin-proposal-class-properties\',\r\n              ],\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n除了上述写法之外，如果觉得 options 配置过于冗余，可以将 options 中的 presets 配置放到 **.babelrc** 文件中，此时就需要在项目根目录下创建一个 `.babelrc` 文件了，配置如下：\r\n\r\n- .babelrc 配置：\r\n\r\n```js\r\n{\r\n  "presets": ["@babel/preset-env", "@babel/preset-react"],\r\n  "plugins": [\r\n    "@babel/plugin-transform-runtime",\r\n    "@babel/plugin-proposal-class-properties",\r\n  ]\r\n}\r\n```\r\n\r\n修改 webpack.common.config.js 文件，将 `babel-loader` 下的 options 配置去除：\r\n\r\n```js\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js(x?)$/,\r\n        exclude: /node_modules/,\r\n        use: [\'babel-loader\'],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n### 安装 React\r\n\r\n```json\r\nyarn add react react-dom\r\n```\r\n\r\n#### 修改 src/index.js\r\n\r\n在 src/index.js 文件中加入 react 相关内容：\r\n\r\n```js\r\nimport React from \'react\';\r\nimport ReactDOM from \'react-dom/client\';\r\n\r\nconst App = () => {\r\n  return (\r\n    <div>\r\n      <h2>hello word</h2>\r\n    </div>\r\n  );\r\n};\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\r\nroot.render(<App />);\r\n```\r\n\r\n### 安装 TypeScript\r\n\r\n#### 安装 @babel/preset-typescript\r\n\r\n**@babel/preset-typescript**：该插件预设了一些 Babel 插件，主要负责编译 TypeScript 语法。\r\n\r\n```json\r\nyarn add @babel/preset-typescript @types/react @types/react-dom -D\r\n\r\nyarn add typescript\r\n```\r\n\r\n#### 增加 tsconfig.json 文件\r\n\r\n在项目根目录下增加 tsconfig.json 文件，内容如下：\r\n\r\n```json\r\n{\r\n  "compilerOptions": {\r\n    "lib": ["dom", "dom.iterable", "esnext"],\r\n    "skipLibCheck": true,\r\n    "esModuleInterop": true,\r\n    "allowSyntheticDefaultImports": true,\r\n    "strict": true,\r\n    "forceConsistentCasingInFileNames": true,\r\n    "noFallthroughCasesInSwitch": true,\r\n    "resolveJsonModule": true,\r\n    "isolatedModules": true,\r\n    "noEmit": false,\r\n    "noImplicitAny": true, // 不允许隐式any类型\r\n    "module": "esnext", // 模块引入方式\r\n    "target": "es5", // 打包后编译成什么形式\r\n    "jsx": "react-jsx", // 引入react\r\n    "allowJs": true, // 在ts文件中允许引入js文件\r\n    "moduleResolution": "node",\r\n    "baseUrl": ".", // 引入模块的方式\r\n    // 路径别名配置\r\n    "paths": {\r\n      "@/*": ["src/*"],\r\n      "@styles/*": ["src/styles/*"]\r\n    }\r\n  },\r\n  "include": ["./src/**/*", "./src/styles/**/*", "react-app-env.d.ts"],\r\n  "exclude": ["node_modules", "dist"]\r\n}\r\n```\r\n\r\n#### 修改 .babelrc 文件\r\n\r\n在 presets 配置中增加编译 ts 的 @babel/preset-typescript 插件：\r\n\r\n```js\r\n{\r\n  "presets": ["@babel/preset-env", "@babel/preset-react", "@babel/preset-typescript"],\r\n  "plugins": [\r\n    "@babel/plugin-transform-runtime",\r\n    "@babel/plugin-proposal-class-properties",\r\n  ]\r\n}\r\n```\r\n\r\n#### 修改 src/index.js 文件\r\n\r\n将 src/index.js 文件改为 `src/index.tsx` 文件，同时将 webpack.common.config.js 文件中的 `entry` 入口改为：`./src/index.tsx`。\r\n\r\n- src/index.tsx：\r\n\r\n```js\r\nimport React from "react";\r\nimport ReactDOM from "react-dom/client";\r\nimport App from "./App";\r\n\r\nconst root = ReactDOM.createRoot(\r\n  document.getElementById("root") as HTMLElement\r\n);\r\nroot.render(<App />);\r\n```\r\n\r\n在 src 中新增 `App.tsx` 文件，内容如下：\r\n\r\n```js\r\nimport React from \'react\';\r\n\r\nconst App = () => {\r\n  return (\r\n    <div>\r\n      <h2>hello word</h2>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n#### 修改 webpack.common.config.js 文件\r\n\r\n修改 `entry` 配置，并且增加编译 `ts | tsx` 的配置。\r\n\r\n```js\r\nmodule.exports = {\r\n  entry: {\r\n    index: \'./src/index.tsx\',\r\n  },\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(js|jsx|ts|tsx)/,\r\n        exclude: /node_modules/,\r\n        use: [\'babel-loader\'],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n在与 plugins 配置同级配置下增加 **resolve** 配置，增加了该配置，在引入文件时就不需要写后缀了。就如上述 `src/index.tsx` 中导入 `./App` 文件一样，可以将 `.tsx` 后缀省略。\r\n\r\n```js\r\nconst path = require(\'path\');\r\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    index: \'./src/index.tsx\',\r\n  },\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n  ],\r\n  resolve: {\r\n    extensions: [\'.js\', \'.jsx\', \'.ts\', \'.tsx\', \'.json\', \'.less\', \'.scss\'],\r\n  },\r\n};\r\n```\r\n\r\n> 此时重启项目看是否能正常运行。\r\n\r\n### 编译 css | less | sass 配置\r\n\r\n#### 安装 css 相关插件\r\n\r\n**style-loader**：通过一个 js 脚本创建一个 style 标签，里面包含一些样式。style-loader 是不能单独使用的，需要与 `css-loader` 一起使用。因为它并不负责解析 css 之前的依赖关系，每个 loader 的功能都是单一的，各自拆分独立。\r\n\r\n**css-loader**：要在 js 中导入 css，就需要使用 css-loader 来识别这个模块，通过特定的语法规则进行转换内容最后导出。\r\n\r\n```json\r\nyarn add style-loader css-loader less less-loader sass sass-loader -D\r\n```\r\n\r\n#### 修改 webpack.dev.config.js 文件\r\n\r\n在 webpack.common.config.js 文件中增加编译 css 的配置，如下：\r\n\r\n```js\r\nconst { merge } = require(\'webpack-merge\');\r\nconst common = require(\'./webpack.common.config.js\');\r\nmodule.exports = merge(common, {\r\n  mode: \'development\',\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(css)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\'style-loader\', \'css-loader\', \'postcss-loader\'],\r\n      },\r\n      {\r\n        test: /\\.(less)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\'style-loader\', \'css-loader\', \'less-loader\', \'postcss-loader\'],\r\n      },\r\n      {\r\n        test: /\\.(scss)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\'style-loader\', \'css-loader\', \'sass-loader\', \'postcss-loader\'],\r\n      },\r\n    ],\r\n  },\r\n  devServer: {\r\n    port: 9102,\r\n    compress: true,\r\n    // 设置 browserHistory 路由模式时，防止出现404的情况\r\n    historyApiFallback: true,\r\n    // 不将错误信息显示在浏览器中\r\n    client: {\r\n      overlay: false,\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n#### 新建 Home.tsx 文件\r\n\r\n在 src 目录中新建 src/Home.tsx 文件及 src/Home.css 文件：\r\n\r\n- Home.tsx 文件内容如下：\r\n\r\n```js\r\nimport React from \'react\';\r\nimport \'./Home.css\';\r\n\r\ninterface IProps {}\r\n\r\nconst Home: React.FC<IProps> = () => {\r\n  return <div className="Home">Home Page</div>;\r\n};\r\n\r\nexport default Home;\r\n```\r\n\r\n- Home.css 文件内容：\r\n\r\n```css\r\n.Home {\r\n  font-size: 22px;\r\n  color: red;\r\n}\r\n```\r\n\r\n#### 新建 App.less 文件\r\n\r\n在 src 目录下创建 App.less 文件，并在 App.tsx 中导入，内容如下：\r\n\r\n- App.less 内容：\r\n\r\n```css\r\n.App {\r\n  background-color: #efefef;\r\n\r\n  .h2 {\r\n    color: skyblue;\r\n  }\r\n}\r\n```\r\n\r\n- App.tsx 内容：\r\n\r\n```js\r\nimport React from \'react\';\r\nimport Home from \'./Home\';\r\nimport \'./App.less\';\r\n\r\nconst App = () => {\r\n  return (\r\n    <div className="App">\r\n      <h2 className="h2">hello word</h2>\r\n      <h2>hello TypeScript</h2>\r\n      <Home />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n#### 新建 index.scss 文件\r\n\r\n在 src 目录下创建 index.less 文件，并在 index.tsx 中导入，内容如下：\r\n\r\n- index.scss 内容：\r\n\r\n```css\r\nbody {\r\n  margin: 0;\r\n  padding: 0;\r\n\r\n  #root {\r\n    border: 1px solid rgb(255, 0, 183);\r\n  }\r\n}\r\n```\r\n\r\n- index.tsx 内容：\r\n\r\n```js\r\nimport React from "react";\r\nimport ReactDOM from "react-dom/client";\r\nimport App from "./App";\r\nimport "./index.scss";\r\n\r\nconst root = ReactDOM.createRoot(\r\n  document.getElementById("root") as HTMLElement\r\n);\r\nroot.render(<App />);\r\n```\r\n\r\n> 此时可以重启项目看是否正常运行了。\r\n\r\n### 配置 PostCSS\r\n\r\nPostCSS 是一个用 JavaScript 工具和插件转换 CSS 代码的工具，具体可点击 [postcss 官方文档](https://github.com/postcss/postcss/blob/main/docs/README-cn.md) 查看\r\n\r\n#### 安装 postcss 相应依赖\r\n\r\n**autoprefixer**：该插件能自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮你自动为 CSS 规则添加前缀。如下：\r\n\r\n```css\r\ndisplay: -webkit-box;\r\ndisplay: -webkit-flex;\r\ndisplay: -ms-flexbox;\r\ndisplay: flex;\r\n-webkit-box-pack: justify;\r\n// ...\r\n```\r\n\r\n```json\r\nyarn add postcss-loader autoprefixer -D\r\n```\r\n\r\n#### 修改 webpack.dev.config.js\r\n\r\n在编译 css | less | scss 的配置中分别增加 postcss-loader：\r\n\r\n```js\r\nmodule.exports = merge(common, {\r\n  mode: \'development\',\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(css)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\'style-loader\', \'css-loader\', \'postcss-loader\'],\r\n      },\r\n      {\r\n        test: /\\.(less)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\'style-loader\', \'css-loader\', \'less-loader\', \'postcss-loader\'],\r\n      },\r\n      {\r\n        test: /\\.(scss)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\'style-loader\', \'css-loader\', \'sass-loader\', \'postcss-loader\'],\r\n      },\r\n    ],\r\n  },\r\n  devServer: {\r\n    port: 9102,\r\n    compress: true,\r\n    // 设置 browserHistory 路由模式时，防止出现404的情况\r\n    historyApiFallback: true,\r\n    // 不将错误信息显示在浏览器中\r\n    client: {\r\n      overlay: false,\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n> **说明**：postcss 需要在 css-loader 之前使用，由于 webpack loader 的使用顺序是遵循从右到左、从下到上的。所以 postcss-loader 必须要放在 css-loader 之后。如果需要配置 antd 自定义主题，那么 postcss-loader 就必须放在 less-loader 之前，如果没有自定义 antd 主题的需求，则放在 less-loader 或者 scss-loader 之前或者之后都可以。\r\n\r\n#### 新增 postcss.config.js 文件\r\n\r\n在根目录中增加 `postcss.config.js` 文件，具体内容如下：\r\n\r\n```js\r\nmodule.exports = {\r\n  plugins: {\r\n    autoprefixer: {\r\n      overrideBrowserslist: [\r\n        \'Android 4.1\',\r\n        \'iOS 7.1\',\r\n        \'Chrome > 31\',\r\n        \'ff > 31\',\r\n        \'ie >= 8\',\r\n      ],\r\n    },\r\n  },\r\n};\r\n```\r\n\r\n### 配置 less | scss 模块化导入\r\n\r\n#### 修改 webpack.dev.config.js\r\n\r\n在编译 `less` 及 `scss` 的 `css-loader` 下配置模块化，具体如下：\r\n\r\n```js\r\nmodule: {\r\n  rules: [\r\n    {\r\n      test: /\\.(css)$/,\r\n      exclude: [/node_modules/],\r\n      use: ["style-loader", "css-loader", "postcss-loader"],\r\n    },\r\n    {\r\n      test: /\\.(less)$/,\r\n      exclude: [/node_modules/],\r\n      use: [\r\n        "style-loader",\r\n        "css-loader",\r\n        {\r\n          loader: "less-loader",\r\n          // css 模块化配置\r\n          options: {\r\n            modules: {\r\n              localIdentName: "[name]__[local]--[hash:base64:5]",\r\n            },\r\n            importLoaders: 1,\r\n          },\r\n        },\r\n        "postcss-loader",\r\n      ],\r\n    },\r\n    {\r\n      test: /\\.(scss)$/,\r\n      exclude: [/node_modules/],\r\n      use: [\r\n        "style-loader",\r\n        {\r\n          loader: "css-loader",\r\n          // css 模块化配置\r\n          options: {\r\n            modules: {\r\n              localIdentName: "[name]__[local]--[hash:base64:5]",\r\n            },\r\n            importLoaders: 1,\r\n          },\r\n        },\r\n        "less-loader",\r\n        "postcss-loader",\r\n      ],\r\n    },\r\n  ],\r\n},\r\n```\r\n\r\n> 如果你想为 css 也配置模块化导入，只需要在匹配 css 的地方加上与 less 下相同的配置即可。但这可能会引起第三方库时，使用非模块化导入其样式无法生效的问题。\r\n\r\n#### 修改 App.tsx 文件\r\n\r\n将样式的引入方式由原来的 `import "./App.less"` 改为：`import styles from "./App.less"`\r\n\r\n```js\r\nimport React from \'react\';\r\nimport Home from \'./Home\';\r\nimport styles from \'./App.less\';\r\n\r\nconst App = () => {\r\n  return (\r\n    <div className={styles.App}>\r\n      <h2 className={styles.h2}>hello word</h2>\r\n      <h2>hello TypeScript</h2>\r\n      <Home />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n#### 处理模块化导入样式引起的 ts 报错\r\n\r\n使用模块化导入样式之后，ts 会报 “找不到模块“./App.less”或其相应的类型声明。ts(2307)” 的错误，此时需要在根目录下新建一个 `typescript.d.ts` 文件，文件名称可以随便取，但是必须以 `.d.ts` 结尾。文件建好之后，需要在其中定义如下声明：\r\n\r\n```js\r\ndeclare module "*.less";\r\n\r\ndeclare module "*.scss";\r\n\r\ndeclare module "*.css";\r\n```\r\n\r\n> 加上上述定义之后，报错就会消失，重启项目看是否能正常运行。\r\n\r\n### 文件与字体引入配置\r\n\r\n在开发过程中需要使用一些图片或者自定义字体，有的需求是直接引用静态服务器，有的是直接打包在工程中。所以需要对引入的图片后者字体做一些处理。\r\n\r\n#### 安装相关依赖\r\n\r\n**url-loader**：url-loader 会将引入的文件进行编码，生成 DataURL，相当于把文件翻译成了一串字符串，再把这个字符串打包到 JavaScript。\r\n\r\n```json\r\nyarn add file-loader url-loader -D\r\n```\r\n\r\n#### 新建 assets/images 文件夹\r\n\r\n在 `assets/images` 文件夹下放入一张本地不图片，并在 `App.tsx` 中导入：\r\n\r\n```js\r\nimport React from \'react\';\r\nimport Home from \'./Home\';\r\nimport styles from \'./App.less\';\r\nimport TEST_IMG from \'./assets/images/test.jpg\';\r\n\r\nconst App = () => {\r\n  return (\r\n    <div className={styles.App}>\r\n      <h2 className={styles.h2}>hello word</h2>\r\n      <h2>hello TypeScript</h2>\r\n      <img src={TEST_IMG} alt="" />\r\n      <Home />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n> 设置完毕之后，重启项目看是否能正常显示图片。\r\n\r\n### 打包生成单独 css 文件\r\n\r\n#### 安装 mini-css-extract-plugin\r\n\r\n**mini-css-extract-plugin**：将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。\r\n\r\n```json\r\nyarn add mini-css-extract-plugin -D\r\n```\r\n\r\n#### 修改 webpack.prod.config.js\r\n\r\n在生产打包配置中增加导入 `"mini-css-extract-plugin`：\r\n\r\n```js\r\nconst { merge } = require(\'webpack-merge\');\r\nconst common = require(\'./webpack.common.config.js\');\r\n\r\nmodule.exports = merge(common, {\r\n  mode: \'production\',\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        exclude: [/node_modules/],\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          {\r\n            loader: \'css-loader\',\r\n            options: {\r\n              modules: {\r\n                localIdentName: \'[name]__[local]--[hash:base64:5]\',\r\n              },\r\n              importLoaders: 1,\r\n            },\r\n          },\r\n          \'postcss-loader\',\r\n        ],\r\n      },\r\n      {\r\n        test: /\\.less$/,\r\n        exclude: [/node_modules/],\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          // 配置less模块化导入\r\n          {\r\n            loader: \'css-loader\',\r\n            options: {\r\n              modules: {\r\n                localIdentName: \'[name]__[local]--[hash:base64:5]\',\r\n              },\r\n              importLoaders: 1,\r\n            },\r\n          },\r\n          \'postcss-loader\',\r\n          \'less-loader\',\r\n        ],\r\n      },\r\n      {\r\n        test: /\\.(sass|scss)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          // 配置scss模块化导入\r\n          {\r\n            loader: \'css-loader\',\r\n            options: {\r\n              modules: {\r\n                mode: \'local\',\r\n                localIdentName: \'[name]__[local]--[hash:base64:5]\',\r\n              },\r\n              importLoaders: 1,\r\n            },\r\n          },\r\n          \'postcss-loader\',\r\n          \'sass-loader\',\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n  plugins: [new MiniCssExtractPlugin()],\r\n});\r\n```\r\n\r\n#### 安装 rimraf\r\n\r\n**rimraf**：以包的形式包装 rm -rf 命令，就是用来删除文件和文件夹的，不管文件夹是否为空，都可以删除。\r\n\r\n```json\r\nyarn add rimraf -D\r\n```\r\n\r\n#### 修改 package.json\r\n\r\n在 `scripts` 脚本中增加开发环境打包配置，以及配置 `rimraf` 命令，在打包时先删除原有得 dist 包。\r\n\r\n```json\r\n"scripts": {\r\n  "start": "webpack serve --config ./config/webpack.dev.config.js",\r\n  "build": "rimraf dist && webpack --config ./config/webpack.prod.config.js",\r\n  "build:dev": "rimraf dist && webpack --config ./config/webpack.dev.config.js",\r\n},\r\n```\r\n\r\n> 上述所有配置都设置完毕之后，即可运行 `npm run build` 及 `npm run build:dev` 看是否能够普正常打包了，同时对比生产配置与开发配置得打包产物是否符合预期。\r\n\r\n### CSS 代码压缩\r\n\r\n#### 安装 css-minimizer-webpack-plugin\r\n\r\n**css-minimizer-webpack-plugin**：该插件用于对 CSS 进行压缩。\r\n\r\n- filename 属性：用与设置打包出来 css 文件放置在 style 目录下。\r\n\r\n```json\r\nyarn add css-minimizer-webpack-plugin -D\r\n```\r\n\r\n#### 修改 webpack.prod.config.js\r\n\r\n在 `webpack.prod.config.js` 文件中导入 css-minimizer-webpack-plugin：\r\n\r\n```js\r\nconst CssMinimizerWebpackPlugin = require(\'css-minimizer-webpack-plugin\');\r\n\r\nmodule.exports = merge(common, {\r\n  mode: \'production\',\r\n  // ...\r\n  plugins: [\r\n    new MiniCssExtractPlugin({\r\n      filename: \'style/[name].[hash:6].css\',\r\n    }),\r\n    new CssMinimizerWebpackPlugin(),\r\n  ],\r\n});\r\n```\r\n\r\n> 设置完毕之后，重新运行 `npm run build` 看样式是否被压缩。\r\n\r\n### 压缩 JS\r\n\r\n#### 安装 terser-webpack-plugin\r\n\r\n**terser-webpack-plugin**：该插件用于压缩 js 文件。\r\n\r\n```json\r\nyarn add terser-webpack-plugin -D\r\n```\r\n\r\n#### 修改 webpack.prod.config.js\r\n\r\n在 `webpack.prod.config.js` 文件中与 `plugins []` 同层级下增加 `optimization` 配置，具体如下：\r\n\r\n```js\r\nconst TerserPlugin = require(\'terser-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  optimization: {\r\n    minimize: true,\r\n    minimizer: [\r\n      new TerserPlugin({\r\n        parallel: true, // 多进程\r\n        extractComments: false, // 删除注释\r\n        terserOptions: {\r\n          compress: {\r\n            drop_console: true, // 去除log\r\n          },\r\n        },\r\n      }),\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n> 运行 `npm run build` 看 js 资源是否进行了压缩。\r\n\r\n### 打包优化\r\n\r\n#### 使用 Externals 减小打包体积\r\n\r\n**Externals**：严格来说使用 Externals 并不是优化代码，而是将一些代码从输出的 bundle 中排除。因为 bundle 将代码排除，所以 bundle 体积会变小，但是 bundle 代码时需要这些依赖的。**这些依赖包需要通过 script 标签的形势引入到 html 文件中**。否则 bundle 将不能正常运行。\r\n\r\n#### 修改 webpack.common.config.js\r\n\r\n使用 `externals` 配置将 `react`、`react-dom` 从打包中排除：\r\n\r\n```js\r\nmodule.exports = {\r\n  // ...\r\n  externals: {\r\n    react: \'React\',\r\n    \'react-dom\': \'ReactDOM\',\r\n  },\r\n};\r\n```\r\n\r\n#### 修改 public/index.html\r\n\r\n将 `react`、`react-dom` 同过 cdn 的形式引入，同时通过环境变量判断导入生产资源还是开发资源：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang="en">\r\n  <head>\r\n    <meta charset="utf-8" />\r\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\r\n    <meta name="theme-color" content="#000000" />\r\n    <meta\r\n      name="description"\r\n      content="Web site created using create-react-app"\r\n    />\r\n    <title>dnhyxc</title>\r\n    <% if (process.env.NODE_ENV === \'development\') { %>\r\n    <script src="https://cdn.staticfile.org/react/18.2.0/umd/react.development.js"><\/script>\r\n    <script src="https://cdn.staticfile.org/react-dom/18.2.0/umd/react-dom.development.js"><\/script>\r\n    <% } else { %>\r\n    <script src="https://cdn.staticfile.org/react/18.2.0/umd/react.production.min.js"><\/script>\r\n    <script src="https://cdn.staticfile.org/react-dom/18.2.0/umd/react-dom.production.min.js"><\/script>\r\n    <% } %>\r\n  </head>\r\n  <body translate="no">\r\n    <div id="root"></div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n### 缓存\r\n\r\n#### 缓存第三方库\r\n\r\n将第三方库（如 react）提取到单独的 vendor chunk 文件中是比较推荐的做法，这是因为它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用 client 的长效缓存机制，命中缓存来消除请求，并减少向 server 获取资源，同时还能保证 client 代码和 server 代码版本一致。\r\n\r\n#### 修改 webpack.common.config.js\r\n\r\n在 webpack.common.config.js 中，与 `externals` 配置同级下增加 `optimization` 配置：\r\n\r\n```js\r\nmodule.exports = {\r\n  externals: {\r\n    react: \'React\',\r\n    \'react-dom\': \'ReactDOM\',\r\n  },\r\n  // 缓存配置\r\n  optimization: {\r\n    splitChunks: {\r\n      cacheGroups: {\r\n        vendor: {\r\n          test: /[\\\\/]node_modules[\\\\/]/,\r\n          name: \'vendor\',\r\n          chunks: \'all\',\r\n        },\r\n      },\r\n    },\r\n  },\r\n};\r\n```\r\n\r\n### antd 按需加载\r\n\r\n#### 安装所需插件\r\n\r\n```json\r\nyarn add babel-plugin-import -D\r\n\r\nyarn add antd\r\n```\r\n\r\n#### 修改 .babelrc 文件\r\n\r\n在 `presets []` 配置同级下增加 `plugins []` 配置实现按需加载：\r\n\r\n```js\r\n{\r\n  "presets": ["@babel/preset-env", "@babel/preset-react", "@babel/preset-typescript"],\r\n  "plugins": [\r\n    "@babel/plugin-transform-runtime",\r\n    "@babel/plugin-proposal-class-properties",\r\n    [\r\n      "import",\r\n      {\r\n        "libraryName": "antd",\r\n        "libraryDirectory": "es", // libraryDirectory 默认为 lib\r\n        "style": true\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```\r\n\r\n> 配置完毕之后，重启项目看按钮样式是否正常展示。\r\n\r\n### 配置 antd 自定义主题\r\n\r\n#### 修改 webpack.dev.config.js\r\n\r\n在原有 `lees-loader` 下方新增加一个 `less-loader`，同时在匹配 `less` 资源的 loader 中加入自定义主题的相关配置。\r\n\r\n使用两个 `less-loader` 的原因是因为：当同时开启 **less 模块化** 与 **antd 自定义主题** 时，会导致 antd 自定义主题失效，所以需要使用两个 less-loader 解决此问题。同时开启 antd 自定义主题的这个 less-loader 必须设置 `include: [/node_modules/]`，开启模块化的则设置为 `exclude: [/node_modules/]`，具体配置如下：\r\n\r\n```js\r\nmodule.exports = merge(common, {\r\n  mode: \'development\',\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      /**\r\n       * 该 less-loader 使用 exclude 排除 node_modules 中的组件库，只针对自己的代码开启 css 模块化\r\n       */\r\n      {\r\n        test: /\\.(less)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\r\n          \'style-loader\',\r\n          // 配置less模块化导入\r\n          {\r\n            loader: \'css-loader\',\r\n            options: {\r\n              modules: {\r\n                localIdentName: \'[name]__[local]--[hash:base64:5]\',\r\n              },\r\n              importLoaders: 1,\r\n            },\r\n          },\r\n          \'postcss-loader\',\r\n          \'less-loader\',\r\n        ],\r\n      },\r\n      {\r\n        test: /\\.less$/,\r\n        include: [/node_modules/],\r\n        use: [\r\n          \'style-loader\',\r\n          \'css-loader\',\r\n          \'postcss-loader\',\r\n          {\r\n            loader: \'less-loader\',\r\n            options: {\r\n              lessOptions: {\r\n                sourceMap: true,\r\n                modifyVars: {\r\n                  \'primary-color\': \'#1DA57A\',\r\n                  \'link-color\': \'#1DA57A\',\r\n                  \'border-radius-base\': \'2px\',\r\n                },\r\n                javascriptEnabled: true,\r\n              },\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      // ...\r\n    ],\r\n  },\r\n});\r\n```\r\n\r\n> 说明：开启 antd 自定义主题时，`postcss-loader` 必须放在 `less-loader` 之上，否则将无法开启自定义主题，控制台将会报错。\r\n\r\n#### 修改 webpack.prod.config.js\r\n\r\n在 webpack.prod.config.js 之中加上与 webpack.dev.config.js 同样的 antd 自定义主题的配置，如下：\r\n\r\n```js\r\nmodule.exports = merge(common, {\r\n  mode: \'development\',\r\n  module: {\r\n    rules: [\r\n      // ...\r\n      /**\r\n       * 该 less-loader 使用 exclude 排除 node_modules 中的组件库，只针对自己的代码开启 css 模块化\r\n       */\r\n      {\r\n        test: /\\.(less)$/,\r\n        exclude: [/node_modules/],\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          // 配置less模块化导入\r\n          {\r\n            loader: \'css-loader\',\r\n            options: {\r\n              modules: {\r\n                localIdentName: \'[name]__[local]--[hash:base64:5]\',\r\n              },\r\n              importLoaders: 1,\r\n            },\r\n          },\r\n          \'postcss-loader\',\r\n          \'less-loader\',\r\n        ],\r\n      },\r\n      {\r\n        test: /\\.less$/,\r\n        include: [/node_modules/],\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          \'css-loader\',\r\n          \'postcss-loader\',\r\n          {\r\n            loader: \'less-loader\',\r\n            options: {\r\n              lessOptions: {\r\n                sourceMap: true,\r\n                modifyVars: {\r\n                  \'primary-color\': \'#1DA57A\',\r\n                  \'link-color\': \'#1DA57A\',\r\n                  \'border-radius-base\': \'2px\',\r\n                },\r\n                javascriptEnabled: true,\r\n              },\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      // ...\r\n    ],\r\n  },\r\n});\r\n```\r\n\r\n以上 antd 相关配置全部配置完毕之后，即可在 `Home.tsx` 中导入 antd 相关组件进行验证了：\r\n\r\n```js\r\nimport React from \'react\';\r\nimport { Button } from \'antd\';\r\nimport \'./Home.css\';\r\n\r\ninterface IProps {}\r\n\r\nconst Home: React.FC<IProps> = () => {\r\n  return (\r\n    <div className="Home">\r\n      <Button type="primary">Home Page</Button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Home;\r\n```\r\n\r\n> 以上设置都设置完毕之后，重启项目，看 antd 按钮样式是否生效，颜色如果为**绿色**而不是蓝色，那就说明自定义主题及 antd 按需加载都生效了。\r\n\r\n### 配置路径别名\r\n\r\n#### 修改 webpack.common.config.js 文件\r\n\r\n在 webpack.common.config.js 中的 `resolve` 配置中增加 `alias` 配置：\r\n\r\n```js\r\nmodule.exports = {\r\n  // ...\r\n  resolve: {\r\n    alias: {\r\n      \'@\': path.resolve(__dirname, \'../src\'),\r\n      \'@styles\': path.resolve(__dirname, \'../src/styles\'),\r\n    },\r\n    extensions: [\'.js\', \'.jsx\', \'.ts\', \'.tsx\', \'.json\', \'.less\', \'.scss\'],\r\n  },\r\n};\r\n```\r\n\r\n#### 创建 src/components 文件\r\n\r\n在 src 目录下 创建 `components` 文件，并在其中创建一个 `Test` 文件夹，在 Test 文件夹下新建一个 `index.tsx` 文件，文件内容如下：\r\n\r\n```js\r\nimport React from \'react\';\r\nimport { Button } from \'antd\';\r\n\r\ninterface IProps {}\r\n\r\nconst Test: React.FC<IProps> = () => {\r\n  return <Button type="link">Test</Button>;\r\n};\r\n\r\nexport default Test;\r\n```\r\n\r\n在 `App.tsx` 中导入 `Test` 组件：\r\n\r\n```js\r\nimport React from \'react\';\r\n// 通过路径别名导入 Test 组件\r\nimport Test from \'@/components/Test\';\r\nimport Home from \'./Home\';\r\nimport styles from \'./App.less\';\r\nimport TEST_IMG from \'./assets/images/test.jpg\';\r\n\r\nconst App = () => {\r\n  return (\r\n    <div className={styles.App}>\r\n      <h2 className={styles.h2}>hello word</h2>\r\n      <h2>hello TypeScript</h2>\r\n      <img src={TEST_IMG} alt="" />\r\n      <Home />\r\n      <Test />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n> 上述配置设置完毕之后，重启项目，看项目是否能正常运行。\r\n\r\n### 配置 ESLint\r\n\r\n#### 安装 eslint 相关插件\r\n\r\n```json\r\nyarn add eslint@latest eslint-loader eslint-webpack-plugin -D\r\n```\r\n\r\n#### 修改 webpack.common.config.js\r\n\r\n在 webpack.common.config.js 增加 `ESLintPlugin`：\r\n\r\n```js\r\nconst ESLintPlugin = require(\'eslint-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    // ...\r\n    new ESLintPlugin(),\r\n  ],\r\n};\r\n```\r\n\r\n#### 新增 .eslintrc.json 文件\r\n\r\n在根目录下新增 `.eslintrc.json` 文件，可以手动进行创建，也可以使用如下命令自动生成：\r\n\r\n```json\r\nnpx eslint --init\r\n```\r\n\r\n运行 `npx eslint --init` 之后，具体选项选择如下：\r\n\r\n- 第一步选择：> To check syntax, find problems, and enforce code style。\r\n\r\n- 第二步选择：> JavaScript modules (import/export)。\r\n\r\n- 第三步选择：> React。\r\n\r\n- 第四步选择：> Does your project use TypeScript? » No / Yes，注意：选择 yes。\r\n\r\n- 第五步选择：> Browser。\r\n\r\n- 第六步选择：> Use a popular style guide。\r\n\r\n- 第七步选择：> Airbnb: https://github.com/airbnb/javascript。\r\n\r\n- 第八步选择：> JSON。\r\n\r\n- 第九步选择：> Would you like to install them now? » No / Yes，注意：选择 yes。\r\n\r\n- 第十步选择：> Which package manager do you want to use? 自己根据情况选择 npm | yarn | pnpm。\r\n\r\n> 执行完上述步骤之后，等待所需包安装完即可。\r\n\r\n如果选择手动创建 `.eslintrc.json` 文件的话，需要自己手动安装如下插件：\r\n\r\n```json\r\nyarn add eslint-config-airbnb eslint-loader eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser -D\r\n```\r\n\r\n> 上述两种方式，推荐使用 `npx eslint --init` 的方式自动生成 `.eslintrc.json` 文件，这样不容易遗漏安装所需要的插件。\r\n\r\n#### 增加 .prettierrc 文件\r\n\r\n在根目录下新增一个 `.prettierrc` 文件，用于设置 Prettier 格式化规则，使格式化好的内容不与 eslint 校验产生冲突，具体可自行根据 eslint 错误提示增加，如下：设置保存时使用单引号：\r\n\r\n- .prettierrc 内容：\r\n\r\n```json\r\n{\r\n  "singleQuote": true\r\n}\r\n```\r\n\r\n#### 修改 .eslint.json 文件\r\n\r\n.eslint.json 文件增加如下设置，其余设置可根据 eslint 提示自行决定是否开启校验，`0` 表示关闭校验。\r\n\r\n```json\r\n{\r\n  "env": {\r\n    "browser": true,\r\n    "es2021": true\r\n  },\r\n  // "plugin:import/typescript"：导入 ts|tsx 文件时，允许省略后缀\r\n  "extends": ["plugin:react/recommended", "airbnb", "plugin:import/typescript"],\r\n  "parser": "@typescript-eslint/parser",\r\n  "parserOptions": {\r\n    "ecmaFeatures": {\r\n      "jsx": true\r\n    },\r\n    "ecmaVersion": "latest",\r\n    "sourceType": "module"\r\n  },\r\n  "plugins": ["react", "@typescript-eslint"],\r\n  "rules": {\r\n    // 关闭 This line has a length of 129. Maximum allowed is 100.\r\n    "max-len": 0,\r\n    // 关闭 \'webpack-merge\' should be listed in the project\'s dependencies, not devDependencies.\r\n    "import/no-extraneous-dependencies": 0,\r\n    // 关闭 Unexpected use of file extension "js" for "./webpack.common.config.js"\r\n    "import/extensions": 0,\r\n    // 关闭 Function component is not a function declaration\r\n    "react/function-component-definition": [\r\n      2,\r\n      {\r\n        "namedComponents": "arrow-function",\r\n        "unnamedComponents": "arrow-function"\r\n      }\r\n    ],\r\n    // 关闭 JSX not allowed in files with extension \'.tsx\'\r\n    "react/jsx-filename-extension": [\r\n      "error",\r\n      { "extensions": [".ts", ".tsx", ".js", ".jsx"] }\r\n    ],\r\n    // 关闭 Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\r\n    "arrow-body-style": 0,\r\n    // 关闭结尾逗号校验\r\n    "comma-dangle": 0\r\n  }\r\n}\r\n```\r\n\r\n#### 解决路径别名 eslint 报错\r\n\r\n当通过路径别名引入组件时，eslint 会报 `Unable to resolve path to module`，为了解决该问题，需要借助如下插件：\r\n\r\n```json\r\nyarn add eslint-import-resolver-webpack -D\r\n```\r\n\r\n修改 `.eslint.json` 文件，增加一个与 `rules` 配置同级的 `settings` 配置：\r\n\r\n```json\r\n"settings": {\r\n  "import/parsers": {\r\n    "@typescript-eslint/parser": [".ts", ".tsx", ".jsx", ".js"]\r\n  },\r\n  "import/resolver": {\r\n    "webpack": {\r\n      "config": "./config/webpack.common.config.js"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### eslint 编写过程中校验 TS\r\n\r\neslint 在代码编写时，默认不会对 ts 代码进行校验，如果需要在编写 ts 代码时，让 eslint 实时给出错误提示，需要进行如下设置：\r\n\r\n- 打开 vscode 设置，在搜索栏中搜索 `Eslint: validate`，搜索到之后，点击 `Edit in setting.json`。\r\n\r\n- 打开 Edit in setting.json 之后，在其中增加如下设置：\r\n\r\n```json\r\n{\r\n  // ...\r\n  "eslint.validate": [\r\n    "javascript",\r\n    "javascriptreact",\r\n    "typescript",\r\n    "typescriptreact"\r\n  ]\r\n}\r\n```\r\n\r\n> 以上设置都设置完毕之后，关闭 vscode 重启，看是否有 eslint 错误提示。\r\n\r\n### 配置 husky\r\n\r\n#### 安装 husky\r\n\r\nhusky 可用于提交代码时进行 eslint 校验，如果有 eslint 报错可阻止代码提交。\r\n\r\n```json\r\nyarn add husky -D\r\n```\r\n\r\n#### 生成 .husky 文件\r\n\r\n在 `package.json` 文件中增加如下两条脚本：\r\n\r\n```json\r\n{\r\n  "scripts": {\r\n    // ...\r\n+   "prepare": "husky install",\r\n+   "test": "npx eslint ./src  --ext ts,tsx,js,jsx"\r\n  }\r\n}\r\n```\r\n\r\n> 注意：`npx eslint ./src` 命令之后必须加上 `--ext ts,tsx,js,jsx` 配置，否则运行脚本时会出现找不到 src 的情况。\r\n\r\n执行如下命令生成 `.husky` 文件，并在该文件夹下生成 `pre-commit` 文件：\r\n\r\n> 注意：执行 npm set-script prepare "husky install" 之前，必须要先使用 git init 创建 .git 文件，否则将会执行失败。\r\n\r\n```json\r\nnpx husky add .husky/pre-commit "npm test"\r\n```\r\n\r\n### webpack 其它配置\r\n\r\n#### 设置 webpack 控制台输出友好提示\r\n\r\n安装 `friendly-errors-webpack-plugin` 插件：\r\n\r\n```js\r\nyarn add friendly-errors-webpack-plugin -D\r\n```\r\n\r\n修改 webpack.common.config.js 文件，增加 `FriendlyErrorsWebpackPlugin` 配置：\r\n\r\n```js\r\nconst FriendlyErrorsWebpackPlugin = require(\'friendly-errors-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    // ...\r\n    new FriendlyErrorsWebpackPlugin(),\r\n  ],\r\n\r\n  // 精简控制台编译输出信息\r\n  stats: {\r\n    modules: false,\r\n    children: false,\r\n    chunks: false,\r\n    chunkModules: false,\r\n  },\r\n};\r\n```\r\n\r\n#### webpack 编译百分比进度条\r\n\r\n该配置不需要安装任何插件，只需要修改 `webpack.common.config.js`，增加如下 `plugins` 配置即可：\r\n\r\n```js\r\nconst webpack = require(\'webpack\');\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    // ...\r\n    new webpack.ProgressPlugin({\r\n      activeModules: false,\r\n      entries: true,\r\n      modules: true,\r\n      modulesCount: 5000,\r\n      profile: false,\r\n      dependencies: true,\r\n      dependenciesCount: 10000,\r\n      percentBy: \'entries\',\r\n    }),\r\n  ],\r\n};\r\n```\r\n\r\n#### webpack 编译条形进度条\r\n\r\n安装如插件：\r\n\r\n```json\r\nyarn add webpackbar -D\r\n```\r\n\r\n修改 webpack.common.config.js 文件，增加 `WebpackBar` plugins 配置：\r\n\r\n```js\r\nconst WebpackBar = require(\'webpackbar\');\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    // ...\r\n    new WebpackBar(),\r\n  ],\r\n};\r\n```\r\n\r\n> 相比条形进度条，个人更推荐百分比进度条。\r\n',date:"2020-09-02",img:s.Z}},{id:"1",detail:{name:"react template",desc:"react + webpack + typescript + eslint 项目搭建",mackdown:'## react 项目搭建\n\n### antd 按需加载\n\n如果项目使用的是 typescript，那么在 webpack 配置中，需要把 antd 按需加载的设置写在编译 ts 中的 `babel-loader` 之下，不能写在编译 js 文件的 `babel-loader` 之下，否则将不生效，具体配置如下：\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.js(x?)$/,\n      exclude: /node_modules/,\n      use: [\n        {\n          loader: "babel-loader",\n          options: {\n            presets: ["@babel/preset-env", "@babel/preset-react", "mobx"],\n            plugins: [\n              "@babel/plugin-transform-runtime",\n              "@babel/plugin-proposal-class-properties",\n            ],\n          },\n        },\n      ],\n    },\n    {\n      test: /\\.ts(x?)$/,\n      exclude: /node_modules/,\n      use: [\n        {\n          loader: "babel-loader",\n          options: {\n            plugins: [\n              [\n                "import",\n                {\n                  libraryName: "antd",\n                  libraryDirectory: "es",\n                  style: true,\n                },\n              ],\n            ],\n          },\n        },\n        "ts-loader",\n      ],\n    },\n  ],\n},\n```\n\n### 解决开启 css 模块化导致 antd 自定义主题失效的问题\n\n解决这个问题需要在 webpack 中配置两次 `less-loader`，在未开启 css 模块化的 less-loader 中设置 antd 自定义主题的配置，在未设置 antd 自定义主题的 less-loader 中开启 css 模块化，具体配置如下：\n\n```js\nmodule: {\n  rules: [\n    /**\n     * 使用两次less-loader解决开启css模块化时导致antd自定义主题失效的问题。\n     * 需要在不开启模块化时，设置antd自定义主题才会生效，因此这一个less-loader使用include针对node_modules中的组件库（即antd）在不开启css块化的情况下，开启自定义主题的设置。\n     *\n     */\n    {\n      test: /\\.less$/,\n      include: [/node_modules/],\n      use: [\n        "style-loader",\n        "css-loader",\n        "postcss-loader",\n        {\n          loader: "less-loader",\n          options: {\n            lessOptions: {\n              // 如果使用less-loader@5，请移除 lessOptions 这一级直接配置选项。\n              sourceMap: true,\n              modifyVars: {\n                "primary-color": "#1DA57A",\n                "link-color": "#1DA57A",\n                "border-radius-base": "2px",\n              },\n              javascriptEnabled: true,\n            },\n          },\n        },\n      ],\n    },\n    /**\n     * 该less-loader使用exclude排除node_modules中的组件库，只针对自己的代码开启css模块化\n     */\n    {\n      test: /\\.less$/,\n      exclude: [/node_modules/],\n      use: [\n        "style-loader",\n        // 配置less模块化导入\n        {\n          loader: "css-loader",\n          options: {\n            modules: {\n              localIdentName: "[name]__[local]--[hash:base64:5]",\n            },\n            importLoaders: 1,\n          },\n        },\n        "postcss-loader",\n        "less-loader",\n      ],\n    },\n  ],\n},\n```\n\n### 防止 browserRouter 路由模式出现 404\n\n需要在 webpack 中的 `devServer` 中配置如下属性：\n\n```js\nhistoryApiFallback: true,\n```\n\n### 解决页面切到子路由时出现找不到 js 资源的报错\n\n要防止刷新页面后出现页面丢失报：`GET http://localhost:9000/home/js/bundle.js net::ERR_ABORTED 404 (Not Found)`，需要在 `output` 中增加 `publicPath` 属性，配置如下：\n\n```js\noutput: {\n  filename: "js/[name]-bundle-[hash:6].js",\n  path: path.resolve(__dirname, "../dist"),\n  publicPath: "/",\n},\n```\n\n### 解决 eslint 与 Prettier 之间的冲突\n\n首先安装如下插件：\n\n```\nyarn add eslint-config-prettier eslint-plugin-prettier -D\n```\n\n之后在 `.eslintrc.js` 中修改如下配置：\n\n```js\n{\n  // ...\n - "extends": ["eslint:recommended", "standard"]\n + "extends": ["eslint:recommended", "standard",  "plugin:prettier/recommended"]\n  // ...\n}\n```\n\n### 解决路径别名 eslint 报错\n\n首先安装如下插件：\n\n```js\nyarn add eslint-import-resolver-webpack -D\n```\n\n增加一个与 rules 配置同级的 settings 配置：\n\n```json\n"import/resolver": {\n  "webpack": {\n    "config": "./config/webpack.common.config.js"\n  }\n}\n```\n\n### 配置 husky\n\n首先需要安装 husky：\n\n```js\nyarn add husky -D\n```\n\n之后执行如下命令生成 `.husky` 文件，并在该文件夹下生成 `pre-commit` 文件：\n\n```js\nnpm set-script prepare "husky install"\n\nnpm run prepare\n\nnpx husky add .husky/pre-commit "npm test"\n```\n\n> 注意：执行 npm set-script prepare "husky install" 之前，必须要先使用 git init 创建 .git 文件，否则将会执行失败。\n\n最后在 `package.json` 文件中增加如下两条脚本：\n\n```js\n{\n  "scripts": {\n    // ...\n+   "prepare": "husky install",\n+   "test": "npx eslint ./src"\n  }\n}\n```\n\n### npx eslint ./src\n\n注意：如果 src 的入口文件是 `.ts | .tsx` 时，执行 `npx eslint ./src` 会出现找不到 src 文件的报错，因此在执行的时候需要加上如下后缀：\n\n```js\nnpx eslint ./src --ext ts,tsx\n```\n\n配置自动修复部分 eslint 报错，只需要在上述脚本的末尾加上 `--fix` 即可：\n\n```js\nnpx eslint ./src --ext ts,tsx --fix\n```\n\n### husky 执行报错处理\n\n当使用 mac 生成 `.husky` 文件时，在 windows 上执行会报：`error: cannot spawn .husky/pre-commit: No such file or directory` 这个错误，出现这个错误的原因是因为 mac 与 windows 两者之间的换行符不同。\n\n解决这个报错的方式是：将原有的 `.husky` 文件删除，重新执行上述命令生成。\n\n### 处理 LF 与 CRLF 转换问题\n\nGit 可以在你 push 时自动地把行结束符 CRLF 转换成 LF，而在 pull 代码时把 LF 转换成 CRLF。用 `core.autocrlf` 来打开此项功能，如果是在 Windows 系统上，把它设置成 `true`，这样当签出代码时，LF 会被转换成 CRLF：\n\n```js\ngit config --global core.autocrlf true\n```\n\nLinux 或 Mac 系统使用 LF 作为行结束符；当一个以 CRLF 为行结束符的文件不小心被引入时你肯定想进行修正，把 `core.autocrlf` 设置成 `input` 来告诉 Git 在 push 时把 CRLF 转换成 LF，pull 时不转换：\n\n```js\ngit config --global core.autocrlf input\n```\n\n在本地和代码库中都保留 LF，无论 pull 还是 push 都不变，代码库什么样，本地还是什么样子：\n\n```js\ngit config --global core.autocrlf false\n```\n',date:"2020-06-13",img:s.Z}},{id:"2",detail:{name:"JSON",desc:"JSON 数据测试",mackdown:'#### JSON\n\n```json\n{\n  "compilerOptions": {\n    "lib": ["dom", "dom.iterable", "esnext"],\n    "skipLibCheck": true,\n    "esModuleInterop": true,\n    "allowSyntheticDefaultImports": true,\n    "strict": true,\n    "forceConsistentCasingInFileNames": true,\n    "noFallthroughCasesInSwitch": true,\n    "resolveJsonModule": true,\n    "isolatedModules": true,\n    "noEmit": false,\n    "noImplicitAny": true, // 不允许隐式any类型\n    "module": "esnext", // 模块引入方式\n    "target": "es5", // 打包后编译成什么形式\n    "jsx": "react-jsx", // 引入react\n    "allowJs": true, // 在ts文件中允许引入js文件\n    "moduleResolution": "node",\n    "baseUrl": ".", // 引入模块的方式\n    "paths": {\n      "@/*": ["src/*"],\n      "@styles/*": ["src/styles/*"]\n    }\n  },\n  "include": ["./src/**/*", "./src/styles/**/*", "react-app-env.d.ts"],\n  "exclude": ["node_modules", "dist"]\n}\n```\n',date:"2020-06-14",img:s.Z}},{id:"3",detail:{name:"JSON",desc:"JSON 数据测试",mackdown:'### eslint\n\n```json\n{\n  "env": {\n    "browser": true,\n    "es2021": true\n  },\n  "extends": [\n    "plugin:react/recommended",\n    "airbnb",\n    "plugin:prettier/recommended"\n  ],\n  "parser": "@typescript-eslint/parser",\n  "parserOptions": {\n    "ecmaFeatures": {\n      "jsx": true\n    },\n    "ecmaVersion": 12,\n    "sourceType": "module"\n  },\n  "plugins": ["react", "@typescript-eslint"],\n  "rules": {\n    "import/extensions": 0,\n    "prettier/prettier": 2,\n    "no-unused-vars": 2, // 开启没有用过的变量检测\n    "import/no-unresolved": [2, { "commonjs": true, "amd": true }],\n    "import/no-extraneous-dependencies": 0,\n    "react/react-in-jsx-scope": 0,\n    "react/function-component-definition": [\n      2,\n      {\n        "namedComponents": "arrow-function",\n        "unnamedComponents": "arrow-function"\n      }\n    ],\n    "react/jsx-filename-extension": [\n      "error",\n      { "extensions": [".ts", ".tsx", ".js", ".jsx"] }\n    ],\n    "no-plusplus": 0,\n    "import/prefer-default-export": 0,\n    "jsx-a11y/click-events-have-key-events": 0,\n    "jsx-a11y/no-noninteractive-element-interactions": 0,\n    "react/jsx-no-undef": 2,\n    "react/require-default-props": 0,\n    "react/jsx-no-useless-fragment": 0,\n    "jsx-a11y/no-static-element-interactions": 0,\n    "no-unused-expressions": 0,\n    "no-use-before-define": 0,\n    "react/no-children-prop": 0,\n    "react/jsx-props-no-spreading": 0,\n    "react/no-unstable-nested-components": 0,\n    "no-nested-ternary": 0\n  },\n  "settings": {\n    "import/parsers": {\n      "@typescript-eslint/parser": [".ts", ".tsx", "jsx", "js"]\n    },\n    "import/resolver": {\n      "webpack": {\n        "config": "./config/webpack.common.config.js"\n      }\n    }\n  }\n}\n```\n',date:"2020-06-15",img:s.Z}},{id:"4",detail:{name:"react",desc:"react 数据测试",mackdown:t,date:"2020-06-16",img:s.Z}},{id:"5",detail:{name:"react18",desc:"react18 配置",mackdown:t,date:"2020-06-17",img:s.Z}},{id:"7",detail:{name:"jsModal",desc:"jsModal 配置",mackdown:"### 模块化简介\r\n\r\n#### 什么是模块化\r\n\r\n将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起。\r\n\r\n模块的内部数据是私有的，只是向外暴露一些接口（方法，API）与外部其它模块进行通信。\r\n\r\n#### 使用模块化的原因\r\n\r\n为了降低复杂度，提高解耦性（降低耦合度），还有为了部署简单。\r\n\r\n#### 模块化的好处\r\n\r\n避免命名冲突，减少对命名空间的污染。\r\n\r\n更好的分离，按需加载。\r\n\r\n使代码具有更高的复用性。\r\n\r\n提高各个模块内代码的可维护性。\r\n\r\n#### 模块化所带来的问题\r\n\r\n引入依赖文件多，导致请求过多。\r\n\r\n各个文件之间的依赖模糊。\r\n\r\n由于依赖关系复杂，导致项目难以维护。\r\n\r\n### 模块化规范\r\n\r\n#### CommonJS\r\n\r\n规范说明：\r\n\r\n- 官方参考文档：[戳这里查看](https://javascript.ruanyifeng.com/nodejs/module.html)\r\n\r\n- 每个文件都可当作一个模块。\r\n\r\n- 在服务器端：模块的加载是运行时同步加载（同步会阻塞代码运行）的。\r\n\r\n- 在浏览器端：模块需要提前编译打包，否则浏览器将解析不出来。\r\n\r\n基本语法：\r\n\r\n- 暴露模块：\r\n\r\n  - `module.exports` = '任意数据类型'\r\n\r\n  - `exports.xxx` = '任意数据类型'\r\n\r\n  - 暴露模块的本质：其实就是向外暴露 exports 对象。exports 原本是一个空对象，使用 `module.exports` 的方式其实就是用`等号` 右边的值覆盖原本空的对象。而`exports.xxx` 的方式就是向 exports 对象中添加 xxx 属性。\r\n\r\n- 引入模块 require(xxx)：\r\n\r\n      - 引入第三方模块：xxx 为模块名。\r\n\r\n      - 引入自定义模块：xxx 为模块文件的路径。\r\n\r\n服务端实现方式：\r\n\r\n- 使用 Node.js 实现。\r\n\r\n浏览器端实现：\r\n\r\n- 需要使用 **[Browserify](http://browserify.org/)** 第三方库进行编译。\r\n\r\n- Browserify 即为 CommonJS 浏览器端的打包工具。\r\n\r\n- browserify 安装方式：\r\n\r\n  - 使用 npm i browserify -g 进行全局安装。\r\n\r\n  - 使用 npm i browserify --save-dev 进行局部安装。\r\n\r\n  - **注意**：首次安装既要在全局安装，也要在局部进行安装。\r\n\r\n- 使用 browserify 在终端进行打包的命令为：browserify js/src/app.js -o js/dist/bundle.js\r\n\r\n      - browserify js/src/app.js 为入口文件。\r\n\r\n      - js/dist/bundle.js 为打包完成后的输出文件。\r\n\r\n      - 入口与出口使用 -o 进行分隔。\r\n\r\n基本使用示例：\r\n\r\n- module1.js 内容：\r\n\r\n```js\r\nmodule.exports = {\r\n  foo() {\r\n    console.log('module1 foo');\r\n  },\r\n};\r\n```\r\n\r\n- module2.js 内容：\r\n\r\n```js\r\nmodule.exports = function () {\r\n  console.log('module2()');\r\n};\r\n```\r\n\r\n- module3.js 内容：\r\n\r\n```js\r\nexports.foo = function () {\r\n  console.log('module3 foo()');\r\n};\r\n\r\nexports.bar = function () {\r\n  console.log('module3 bar()');\r\n};\r\n```\r\n\r\n- app.js 内容：\r\n\r\n```js\r\nlet module1 = require('./module1');\r\nlet module2 = require('./module2');\r\nlet module3 = require('./module3');\r\n\r\nmodule1.foo(); // module1 foo\r\nmodule2(); // module2()\r\nmodule3.foo(); // module3 foo()\r\nmodule3.bar(); // module3 bar()\r\n```\r\n\r\n- index.html 内容：\r\n\r\n```html\r\n<body>\r\n  <h2>使用browserify打包命令</h2>\r\n  <p>browserify js/src/app.js -o js/dist/bundle.js</p>\r\n  <script src=\"./js/dist/bundle.js\"><\/script>\r\n</body>\r\n```\r\n\r\n#### AMD\r\n\r\nAMD 规范说明：\r\n\r\n- AMD 全称为：Asynchronous Module Definition（异步模块定义）。\r\n\r\n- 官方参考文档：[戳这里查看](https://github.com/amdjs/amdjs-api)。\r\n\r\n- AMD 是专门用于浏览器端的，且模块的加载是异步的（即不会阻塞代码运行）。\r\n\r\n基本语法：\r\n\r\n- 定义暴露模块：\r\n\r\n  - 定义没有依赖的模块：\r\n\r\n  ```js\r\n  define(function () {\r\n    return 模块;\r\n  });\r\n  ```\r\n\r\n  - 定义有依赖的模块：\r\n\r\n  ```js\r\n  define(['module1', 'module2'], function (m1, m2) {\r\n    return 模块;\r\n  });\r\n  ```\r\n\r\n- 引入使用模块：\r\n\r\n```js\r\nrequire(['module1', 'module2'], function(m1, m2) {\r\n    使用 m1/m2\r\n})\r\n```\r\n\r\n浏览器端实现：\r\n\r\n- 需要依赖于 [Require.js](https://requirejs.org/) 实现。\r\n\r\n基本使用示例：\r\n\r\n- dataService.js 内容：\r\n\r\n```js\r\n// 定义没有依赖的模块\r\ndefine(function () {\r\n  let name = 'dataService.js__require.js';\r\n  function getName() {\r\n    return name;\r\n  }\r\n\r\n  // 向外暴露模块\r\n  return { getName };\r\n});\r\n```\r\n\r\n- data.js 内容：\r\n\r\n```js\r\n// 定义有依赖的模块\r\ndefine(// 参数一为：一个数组，数组中保存的就是依赖模块，为字符串类型\r\n['dataService'], function (dataService) {\r\n  // 参数二为：一个函数，参数为依赖的模块\r\n  let msg = 'data.js——AMD';\r\n  function showMsg() {\r\n    console.log(msg, dataService.getName());\r\n  }\r\n  return { showMsg };\r\n});\r\n```\r\n\r\n- main.js 内容：\r\n\r\n```js\r\n(function () {\r\n  requirejs.config({\r\n    baseUrl: 'js/', // 表示基本路径\r\n    paths: {\r\n      // 配置路径，注意不能加 .js 后缀，否则会报错\r\n      dataService: './modules/dataService',\r\n      data: './modules/data',\r\n    },\r\n  });\r\n  requirejs(['data'], function (data) {\r\n    data.showMsg();\r\n  });\r\n})();\r\n```\r\n\r\n- index.html 内容：\r\n\r\n```html\r\n<body>\r\n  <h3>使用 Require.js 规范实现模块化</h3>\r\n  \x3c!-- 使用CDN引入require.js --\x3e\r\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/require.js/2.3.5/require.min.js\"><\/script>\r\n  <script src=\"./js/main.js\"><\/script>\r\n</body>\r\n```\r\n\r\n#### ES6 模块化\r\n\r\nES6 模块化规范说明：\r\n\r\n- 依赖模块需要编译打包处理。\r\n\r\n语法：\r\n\r\n- 导出模块使用：export。\r\n\r\n- 引入模块使用：import。\r\n\r\n浏览器端实现：\r\n\r\n- 需要依赖于 [Babel](https://babeljs.io/) 实现。\r\n\r\nBabel 基本使用：\r\n\r\n- 需要安装：babel-cli，babel-preset-es2015 和 browserify。\r\n- **注意**：需要在全局安装 babel-cli。\r\n\r\n  - npm i babel-cli browserify -g\r\n\r\n  - npm i babel-preset-es2015 --save-dev\r\n\r\n- 配置 .babelrc 文件：\r\n\r\n```\r\n{\r\n  \"presets\": [\"es2015\"]\r\n}\r\n```\r\n\r\n- 编译命令：\r\n\r\n  - 使用 **babel js/src -d js/build** 将模块内容转化为 ES5 的格式。\r\n  - 在使用 **browserify js/build/main.js -o js/dist/bundle.js** 将模块内容编译成浏览器能够识别的内容。\r\n\r\n基本使用示例：\r\n\r\n- module1.js 内容：\r\n\r\n```js\r\n// 暴露模块\r\nexport function foo() {\r\n  console.log('foo() module1__ES6');\r\n}\r\n\r\nexport function bar() {\r\n  console.log('bar() module1__ES6');\r\n}\r\n\r\nexport let arr = [1, 2, 3, 4, 5];\r\n```\r\n\r\n- module2.js 内容：\r\n\r\n```js\r\nfunction fun() {\r\n  console.log('fun() module2');\r\n}\r\n\r\nfunction fun2() {\r\n  console.log('fun2() module2');\r\n}\r\n\r\nexport { fun, fun2 };\r\n```\r\n\r\n- module3.js 内容：\r\n\r\n```js\r\nexport default () => {\r\n  console.log('使用 export default 默认暴露');\r\n};\r\n```\r\n\r\n- module4.js 内容：\r\n\r\n```js\r\n// 暴露模块\r\nexport function fn() {\r\n  console.log('fn() module1__ES6');\r\n}\r\n\r\nexport function fn2() {\r\n  console.log('fn2() module1__ES6');\r\n}\r\n\r\nexport let obj = { name: 'snsn' };\r\n```\r\n\r\n- main.js 内容：\r\n\r\n```js\r\nimport { foo, bar, arr } from './module1';\r\nimport { fun, fun2 } from './module2';\r\nimport module3 from './module3';\r\n// 一次性导入全部\r\nimport * as module4 from './module4';\r\n\r\nfoo(); // foo() module1__ES6\r\nbar(); // bar() module1__ES6\r\nconsole.log(arr); // [1, 2, 3, 4, 5]\r\nfun(); // fun() module2\r\nfun2(); // fun2() module2\r\nmodule3(); // 使用 export default 默认暴露\r\nconsole.log(module4); // Object{fn,fn2,obj}\r\nmodule4.fn(); // fn() module1__ES6\r\nmodule4.fn2(); // fn2() module1__ES6\r\nconsole.log(module4.obj.name); // snsn\r\n```\r\n\r\n- index.html 内容：\r\n\r\n```html\r\n<body>\r\n  <h2>使用ES6实现模块化</h2>\r\n  <script src=\"./js/dist/bundle.js\"><\/script>\r\n</body>\r\n```\r\n",date:"2020-06-17",img:s.Z}}],l=[{value:3,name:"前端框架"},{value:30,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:2,name:"vue"},{value:3,name:"前端框架"},{value:10,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:2,name:"vue"},{value:3,name:"前端框架"},{value:10,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:20,name:"vue"},{value:3,name:"前端框架"},{value:30,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:2,name:"vue"},{value:3,name:"前端框架"},{value:10,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:2,name:"vue"},{value:3,name:"前端框架"},{value:10,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:20,name:"vue"},{value:3,name:"前端框架"},{value:30,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:2,name:"vue"},{value:3,name:"前端框架"},{value:10,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:2,name:"vue"},{value:3,name:"前端框架"},{value:10,name:"JavaScript"},{value:10,name:"CSS"},{value:2,name:"HTML"},{value:12,name:"react"},{value:2,name:"webpack"},{value:1,name:"mobx"},{value:20,name:"vue"},{value:20,name:"哈哈哈哈哈"},{value:20,name:"拉倒吧"},{value:20,name:"拉倒吧啊啊"},{value:20,name:"拉倒吧啊啊"},{value:1,name:"曦曦曦曦"},{value:1,name:"曦曦曦曦"},{value:1,name:"曦曦曦曦"},{value:1,name:"曦曦曦曦"},{value:1,name:"曦曦曦曦"},{value:1,name:"曦曦曦曦"},{value:1,name:"曦曦曦曦"},{value:1,name:"曦曦曦曦"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"},{value:2,name:"晨晨"}],i=[{tagName:"前端",child:[{id:1,name:"js 算法",count:1},{id:2,name:"js 算法",count:1},{id:3,name:"dom",count:10},{id:4,name:"bom",count:5},{id:5,name:"js 面试",count:2}]},{tagName:"后端",child:[{id:1,name:"网页换肤",count:2},{id:2,name:"网页换肤",count:2},{id:3,name:"语义化标签",count:2},{id:4,name:"行内元素",count:2},{id:5,name:"块级元素",count:2}]},{tagName:"架构",child:[{id:1,name:"flex布局",count:2},{id:2,name:"瀑布流布局",count:2},{id:3,name:"双飞翼布局",count:3}]},{tagName:"开发工具",child:[{id:1,name:"hooks",count:3},{id:2,name:"虚拟dom",count:3},{id:3,name:"fiber",count:3}]}]},6701:(n,r,e)=>{e.d(r,{Z:()=>C});var s=e(47912),t=e(35736),o=e(67724),a=e(29439),l=function(){var n=(0,s.useState)(window.innerWidth),r=(0,a.Z)(n,2),e=r[0],t=r[1];(0,s.useEffect)((function(){return window.addEventListener("resize",o),function(){window.removeEventListener("resize",o)}}),[]);var o=function(){var n=window.innerWidth;t(n)};return{htmlWidth:e}},i=(e(54463),e(51530)),c=(e(93816),e(64078)),d=(e(32308),e(97494)),p=e(5405),m=e(28612),u=e(19675),b=e(80411),j=e.n(b);const f="index__MenuList--cqG6n",g="index__item--suNWa",x="index__itemIcon--qwj27",h="index__dropdown--Qupg9",y="index__space--NbJLy",v="index__selectMenu--JYoNo",k="index__menuIcon--u2ACC",w="index__activeMenu--DEwhu",_="index__menu_label--do1An";var S=[{key:"home",name:"主页",path:"/home"},{key:"classify",name:"分类",path:"/classify"},{key:"tag",name:"标签",path:"/tag"},{key:"timeline",name:"时间轴",path:"/timeline"},{key:"about",name:"关于我",path:"/about"},{key:"create",name:"发布文章",path:"/create"}];const E=function(n){var r=n.className,e=n.children,o=(0,t.useNavigate)(),b=l().htmlWidth,E=(0,s.useState)(!1),A=(0,a.Z)(E,2),C=A[0],L=A[1],N=s.createElement(d.Z,{items:S.map((function(n){return{key:n.key,label:s.createElement(t.Link,{to:n.path,className:_},n.name)}}))});return s.createElement("div",{className:j()(f,r)},b<960?s.createElement("span",{className:x},s.createElement(i.Z,{overlayClassName:h,placement:"bottom",overlay:N,onVisibleChange:function(n){L(n)}},s.createElement(c.Z,{className:y},s.createElement("span",{className:v},s.createElement(p.Z,{className:k})),C?s.createElement(m.Z,{className:C?w:""}):s.createElement(u.Z,null)))):S.map((function(n){return s.createElement(s.Fragment,{key:n.name},s.createElement("span",{className:g,onClick:function(r){return function(n,r){n.preventDefault(),o(r)}(r,n.path)}},n.name),e)})))},A={clickNoSelectText:"index__clickNoSelectText--a9aXj",webkitScrollbarStyle:"index__webkitScrollbarStyle--Le0pe",herderWrap:"index__herderWrap--UcnAP",left:"index__left--T5DZY",child:"index__child--Qh3gZ",back:"index__back--D3OeY"};const C=function(n){var r=n.children,e=n.left,a=n.right,i=n.needLeft,c=void 0!==i&&i,d=n.needMenu,p=void 0!==d&&d,m=n.excludesWidth,u=void 0!==m&&m,b=(0,t.useNavigate)(),j=l().htmlWidth;return s.createElement("div",{className:A.herderWrap},s.createElement("div",{className:A.left},c&&(e||s.createElement("div",{className:A.back,onClick:function(){b(-1)}},s.createElement(o.Z,null))),s.createElement("div",{className:A.child},r),u?p&&s.createElement(E,null):p&&j<=960&&s.createElement(E,null)),a&&s.createElement("div",{className:A.right},a))}}}]);